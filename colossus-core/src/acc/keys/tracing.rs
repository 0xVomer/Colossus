/// Covercrypt tracing secret key.
///
/// It allows creating tracing encapsulations. Such encapsulations can only be
/// opened by a specific USK or combination of USKs (which IDs are known). The
/// number of tracers in the key defines the tracing level. Any key generated by
/// a number of users strictly lower than this level can be traced.
///
/// For example, if the tracing level is two, any collusion of up to two users
/// can be traced.
///
/// It is composed of:
/// - a generator
/// - the tracers;
/// - the set of known user IDs.
#[derive(Debug, PartialEq, Eq)]
pub struct TracingSecretKey {
    s: <ElGamal as Nike>::SecretKey,
    tracers: LinkedList<(<ElGamal as Nike>::SecretKey, <ElGamal as Nike>::PublicKey)>,
    users: HashSet<UserId>,
}

impl TracingSecretKey {
    fn new_with_level(level: usize, rng: &mut impl CryptoRngCore) -> Result<Self, Error> {
        let s = <ElGamal as Nike>::SecretKey::random(rng);
        let tracers = (0..=level).map(|_| ElGamal::keygen(rng)).collect::<Result<_, _>>()?;
        let users = HashSet::new();

        Ok(Self { s, tracers, users })
    }

    /// Returns the current tracing level.
    fn tracing_level(&self) -> usize {
        self.tracers.len() - 1
    }

    fn set_traps(&self, r: &<ElGamal as Nike>::SecretKey) -> Vec<<ElGamal as Nike>::PublicKey> {
        self.tracers.iter().map(|(_, Pi)| Pi * r).collect()
    }

    /// Generates a new tracer. Returns the associated trap.
    fn _increase_tracing(&mut self, rng: &mut impl CryptoRngCore) -> Result<(), Error> {
        self.tracers.push_back(ElGamal::keygen(rng)?);
        Ok(())
    }

    /// Drops the oldest tracer and returns it.
    fn _decrease_tracing(
        &mut self,
    ) -> Result<(<ElGamal as Nike>::SecretKey, <ElGamal as Nike>::PublicKey), Error> {
        if self.tracing_level() == MIN_TRACING_LEVEL {
            Err(Error::OperationNotPermitted(format!(
                "tracing level cannot be lower than {MIN_TRACING_LEVEL}"
            )))
        } else {
            Ok(self
                .tracers
                .pop_front()
                .expect("previous check ensures the queue is never empty"))
        }
    }

    /// Set the level of the tracing secret key to the target level.
    pub fn _set_tracing_level(
        &mut self,
        rng: &mut impl CryptoRngCore,
        target_level: usize,
    ) -> Result<(), Error> {
        if target_level < self.tracing_level() {
            for _ in target_level..self.tracing_level() {
                self._decrease_tracing()?;
            }
        } else {
            for _ in self.tracing_level()..target_level {
                self._increase_tracing(rng)?;
            }
        }
        Ok(())
    }

    /// Returns true if the given user ID is known.
    fn is_known(&self, id: &UserId) -> bool {
        self.users.contains(id)
    }

    /// Adds the given user ID to the list of known users.
    fn add_user(&mut self, id: UserId) {
        self.users.insert(id);
    }

    /// Removes the given user ID from the list of known users.
    ///
    /// Returns true if the user was in the list.
    fn del_user(&mut self, id: &UserId) -> bool {
        self.users.remove(id)
    }

    /// Generates the associated tracing public key.
    #[must_use]
    fn tpk(&self) -> TracingPublicKey {
        TracingPublicKey(self.tracers.iter().map(|(_, Pi)| Pi).cloned().collect())
    }

    /// Returns the binding points.
    fn binding_point(&self) -> <ElGamal as Nike>::PublicKey {
        (&self.s).into()
    }

    /// Generates a new ID and adds it to the list of known user IDs.
    fn generate_user_id(&mut self, rng: &mut impl CryptoRngCore) -> Result<UserId, Error> {
        if let Some((last_tracer, _)) = self.tracers.back() {
            // Generate all but the last marker at random.
            let mut markers = self
                .tracers
                .iter()
                .take(self.tracers.len() - 1)
                .map(|_| <ElGamal as Nike>::SecretKey::random(rng))
                .collect::<LinkedList<_>>();

            let last_marker = ((&self.s
                - &self
                    .tracers
                    .iter()
                    .zip(markers.iter())
                    .map(|((sk_i, _), a_i)| sk_i * a_i)
                    .fold(<ElGamal as Nike>::SecretKey::zero(), |acc, x_i| acc + x_i))
                / last_tracer)?;

            markers.push_back(last_marker);
            let id = UserId(markers);
            self.add_user(id.clone());
            Ok(id)
        } else {
            Err(Error::KeyError("MSK has no tracer".to_string()))
        }
    }

    /// Returns true if the given user ID is valid.
    fn _validate_user_id(&self, id: &UserId) -> bool {
        self.s
            == id
                .iter()
                .zip(self.tracers.iter())
                .map(|(identifier, (tracer, _))| identifier * tracer)
                .sum()
    }

    /// If the tracing level of the user ID is not in sync with the one of the
    /// MSK, generate a new ID with the correct tracing level and replace the
    /// old ID by the new one in the MSK.
    ///
    /// # Error
    ///
    /// Returns an error if the ID is unknown.
    fn refresh_id(&mut self, rng: &mut impl CryptoRngCore, id: UserId) -> Result<UserId, Error> {
        if !self.is_known(&id) {
            Err(Error::Tracing("unknown user".to_string()))
        } else if id.tracing_level() != self.tracing_level() {
            let new_id = self.generate_user_id(rng)?;
            self.add_user(new_id.clone());
            self.del_user(&id);
            Ok(new_id)
        } else {
            // Since the integrity of the USK is checked, there is no need to
            // validated the ID before returning it. This saves O(tracing-level)
            // multiplications... but there is actually no way to locally check
            // the caller actually checked the integrity first.
            Ok(id)
        }
    }
}

/// Covercrypt tracing public key.
#[derive(Debug, PartialEq, Eq, Default)]
struct TracingPublicKey(LinkedList<<ElGamal as Nike>::PublicKey>);

impl TracingPublicKey {
    /// Returns the tracing level tracing of this key.
    fn tracing_level(&self) -> usize {
        self.0.len() - 1
    }
}
